/* eslint-disable */
// @ts-nocheck
// This file is automatically generated using graphql-code-generator
import { GraphQLResolveInfo } from "graphql";
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> &
  { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> &
  { [SubKey in K]: Maybe<T[SubKey]> };
export type RequireFields<T, K extends keyof T> = {
  [X in Exclude<keyof T, K>]?: T[X];
} &
  { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};

export type Ability = {
  __typename?: "Ability";
  name: Scalars["String"];
  url: Scalars["String"];
};

export type AbilityData = {
  __typename?: "AbilityData";
  ability?: Maybe<Ability>;
};

export type Description = {
  __typename?: "Description";
  flavor_text: Scalars["String"];
  language: LanguageData;
  version: VersionData;
};

export type LanguageData = {
  __typename?: "LanguageData";
  name: Scalars["String"];
  url: Scalars["String"];
};

export type Pokemon = {
  __typename?: "Pokemon";
  id: Scalars["Int"];
  name: Scalars["String"];
  abilities?: Maybe<Array<Maybe<AbilityData>>>;
  stats?: Maybe<Array<Maybe<StatsData>>>;
  description?: Maybe<Array<Maybe<Description>>>;
};

export type Query = {
  __typename?: "Query";
  getPokemon?: Maybe<Pokemon>;
  getDescription?: Maybe<Description>;
};

export type QueryGetPokemonArgs = {
  id: Scalars["Int"];
};

export type QueryGetDescriptionArgs = {
  id: Scalars["Int"];
};

export type Stats = {
  __typename?: "Stats";
  name: Scalars["String"];
  url: Scalars["String"];
};

export type StatsData = {
  __typename?: "StatsData";
  stat: Stats;
  base_stat: Scalars["Int"];
};

export type VersionData = {
  __typename?: "VersionData";
  name: Scalars["String"];
  url: Scalars["String"];
};

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {}
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
  obj: T,
  context: TContext,
  info: GraphQLResolveInfo
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {}
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  Ability: ResolverTypeWrapper<Ability>;
  String: ResolverTypeWrapper<Scalars["String"]>;
  AbilityData: ResolverTypeWrapper<AbilityData>;
  Description: ResolverTypeWrapper<Description>;
  LanguageData: ResolverTypeWrapper<LanguageData>;
  Pokemon: ResolverTypeWrapper<Pokemon>;
  Int: ResolverTypeWrapper<Scalars["Int"]>;
  Query: ResolverTypeWrapper<{}>;
  Stats: ResolverTypeWrapper<Stats>;
  StatsData: ResolverTypeWrapper<StatsData>;
  VersionData: ResolverTypeWrapper<VersionData>;
  Boolean: ResolverTypeWrapper<Scalars["Boolean"]>;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  Ability: Ability;
  String: Scalars["String"];
  AbilityData: AbilityData;
  Description: Description;
  LanguageData: LanguageData;
  Pokemon: Pokemon;
  Int: Scalars["Int"];
  Query: {};
  Stats: Stats;
  StatsData: StatsData;
  VersionData: VersionData;
  Boolean: Scalars["Boolean"];
};

export type AbilityResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Ability"] = ResolversParentTypes["Ability"]
> = {
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AbilityDataResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["AbilityData"] = ResolversParentTypes["AbilityData"]
> = {
  ability?: Resolver<Maybe<ResolversTypes["Ability"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DescriptionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Description"] = ResolversParentTypes["Description"]
> = {
  flavor_text?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  language?: Resolver<ResolversTypes["LanguageData"], ParentType, ContextType>;
  version?: Resolver<ResolversTypes["VersionData"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LanguageDataResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["LanguageData"] = ResolversParentTypes["LanguageData"]
> = {
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PokemonResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Pokemon"] = ResolversParentTypes["Pokemon"]
> = {
  id?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  abilities?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["AbilityData"]>>>,
    ParentType,
    ContextType
  >;
  stats?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["StatsData"]>>>,
    ParentType,
    ContextType
  >;
  description?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Description"]>>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Query"] = ResolversParentTypes["Query"]
> = {
  getPokemon?: Resolver<
    Maybe<ResolversTypes["Pokemon"]>,
    ParentType,
    ContextType,
    RequireFields<QueryGetPokemonArgs, "id">
  >;
  getDescription?: Resolver<
    Maybe<ResolversTypes["Description"]>,
    ParentType,
    ContextType,
    RequireFields<QueryGetDescriptionArgs, "id">
  >;
};

export type StatsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Stats"] = ResolversParentTypes["Stats"]
> = {
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatsDataResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["StatsData"] = ResolversParentTypes["StatsData"]
> = {
  stat?: Resolver<ResolversTypes["Stats"], ParentType, ContextType>;
  base_stat?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VersionDataResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["VersionData"] = ResolversParentTypes["VersionData"]
> = {
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  url?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  Ability?: AbilityResolvers<ContextType>;
  AbilityData?: AbilityDataResolvers<ContextType>;
  Description?: DescriptionResolvers<ContextType>;
  LanguageData?: LanguageDataResolvers<ContextType>;
  Pokemon?: PokemonResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  Stats?: StatsResolvers<ContextType>;
  StatsData?: StatsDataResolvers<ContextType>;
  VersionData?: VersionDataResolvers<ContextType>;
};
